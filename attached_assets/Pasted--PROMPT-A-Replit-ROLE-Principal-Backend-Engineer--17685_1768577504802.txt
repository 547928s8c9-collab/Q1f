Вот PROMPT A одним куском (копипаст в Replit без правок):

⸻

ROLE: Ты — Principal Backend Engineer (TypeScript/Node.js) в существующем репозитории Replit. Стек и ограничения: Node.js + TypeScript, Express, Postgres, Drizzle ORM. Уже есть server/db.ts, server/storage.ts (DatabaseStorage), канонический журнал денег operations, роутинг через server/routes.ts, и /api/bootstrap. НЕЛЬЗЯ добавлять новые базы/очереди/языки/воркеры. Всё делаем внутри текущего проекта и в том же стиле. ЦЕЛЬ ИТЕРАЦИИ A (MARKET DATA FOUNDATION): добавить фундамент рыночных данных Binance Spot (публичные свечи klines) + хранение в Postgres, чтобы следующие итерации могли проигрывать историю “как лайв” и строить графики без повторных запросов к Binance. РЕЗУЛЬТАТ: таблица market_candles (Drizzle + миграция), загрузчик исторических данных (REST Binance) с догрузкой диапазонов, retry/backoff на 429 и временные ошибки, идемпотентный upsert, минимальный API для чтения свечей, и короткий self-test/скрипт для проверки.
	0.	Repo reconnaissance (в начале отчёта кратко): где Drizzle schema + миграции; где подключаются роуты; как устроен server/storage.ts/DatabaseStorage; как формируется /api/bootstrap (на будущее).
	1.	DB: создать таблицу market_candles (Drizzle schema + миграция). Поля: id (как принято: serial/uuid), exchange text (например "binance_spot"), symbol text (например "BTCUSDT"), timeframe text (например "15m"|"1h"|"1d"; на старте достаточно text), ts bigint (UTC ms, начало свечи), open numeric/decimal, high numeric/decimal, low numeric/decimal, close numeric/decimal, volume numeric/decimal, created_at, updated_at. Ограничения: UNIQUE(exchange,symbol,timeframe,ts). Индексы: (exchange,symbol,timeframe,ts) и (symbol,timeframe,ts). Важно: хранить цены как decimal/numeric, как принято в проекте (не float).
	2.	Binance REST client (публичный, без ключей): реализовать модуль server/marketdata/binance.ts с функцией fetchKlines({ symbol, interval, startTime?, endTime?, limit? }) вызывающей Binance Spot endpoint GET https://api.binance.com/api/v3/klines и возвращающей массив свечей в нормализованном формате (ts=openTime, open/high/low/close/volume). Ограничения Binance: limit до 1000 (использовать 1000 по умолчанию). Обрабатывать HTTP ошибки и таймауты.
	3.	DataLoader (история диапазона + догрузка): создать server/marketdata/loader.ts с функцией backfillCandles({ exchange="binance_spot", symbol, timeframe, startTs, endTs, batchLimit=1000 }). Логика: циклом запрашивать klines чанками от startTs к endTs, двигаясь по времени (следующий start = lastKlineTs + timeframeMs). Вставка в БД должна быть идемпотентной: использовать upsert/ON CONFLICT DO UPDATE по UNIQUE ключу. Добавить throttling: небольшая задержка между запросами (например 200–400ms), чтобы не упереться в лимиты. Retry/backoff: при 429 — экспоненциальный backoff (например 1s, 2s, 4s, 8s, max 30s) и повтор; при 5xx/сетевых — 3–5 повторов с backoff; при 4xx (кроме 429) — фейлить с понятной ошибкой. Вести логи прогресса (сколько свечей загружено, текущий диапазон).
	4.	“Ensure coverage” helper: добавить ensureCandlesRange({ symbol, timeframe, startTs, endTs }), который проверяет наличие данных в БД (по min/max ts и/или count) и при необходимости догружает недостающий диапазон через backfillCandles. На этом шаге допускается простой подход: если minTs>startTs или maxTs<endTs — догружаем соответствующие хвосты; точные “дыры” внутри диапазона можно оставить на итерацию E, но желательно хотя бы уметь догружать хвост/голову.
	5.	Read API (для UI и будущего раннера): создать server/marketdata/routes.ts и подключить в server/routes.ts под /api/market. Эндпоинты: (a) GET /api/market/candles?exchange=binance_spot&symbol=BTCUSDT&timeframe=15m&fromTs=...&toTs=...&limit=... — отдаёт свечи из БД, сортировка asc, лимит по умолчанию 500; (b) POST /api/market/backfill (защищать как минимум простой server-side guard, если в проекте есть auth — только админам; если нет — хотя бы скрыть за env-флагом) body: { symbol, timeframe, startTs, endTs } запускает backfill синхронно (на этом шаге ок) и возвращает статистику (сколько вставлено/обновлено). Формат ответов: использовать существующие envelope-хелперы ok()/fail() если они есть в проекте (например из admin модуля), чтобы быть консистентными.
	6.	Self-test / how to verify: добавить простой скрипт server/marketdata/selftest.ts (или npm script), который: (1) вызывает backfillCandles для BTCUSDT 15m за небольшой диапазон (например последние 2 дня), (2) потом читает из БД свечи и проверяет: записи есть, ts возрастают, уникальность ключа не ломается, повторный запуск не удваивает записи. В отчёте дать точные команды как запустить тест и какой ожидаемый вывод.
	7.	Acceptance criteria (готово если): миграция применена; market_candles наполняется; повторный backfill идемпотентен; 429/5xx корректно ретраятся; GET /api/market/candles отдаёт данные быстро и стабильно; selftest проходит.

DELIVERABLES: новые/изменённые файлы (Drizzle schema + миграция), server/marketdata/binance.ts, server/marketdata/loader.ts, server/marketdata/routes.ts, selftest, и короткий отчёт “что сделано / как проверить”.

⸻
